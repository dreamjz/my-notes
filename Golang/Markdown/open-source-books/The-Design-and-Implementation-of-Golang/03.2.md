---
title: '3.2 Golang 切片实现原理'
date: '2021-03-25'
categories:
 - golang
tags: 
 - array
publish: true
---

相较于数组，Go 语言中更常用的数据结构是切片，即动态数组，其长度并不固定，可以向切片中追加元素，它会在容量不足时自动扩容。

切片的声明和数组类似，因为切片的长度是动态的，所以声明时只需指定切片中元素类型：

```go
[]int
[]interface{}
```

从切片的定义可以看出，切片在编译期间的生成的类型只会包含切片中的元素类型，即 `int` 或者 `interface{}` 等。[`cmd/compile/internal/types.NewSlice`](https://draveness.me/golang/tree/cmd/compile/internal/types.NewSlice) 就是编译期间用于创建切片类型的函数：

```go
func NewSlice(elem *Type) *Type {
	if t := elem.Cache.slice; t != nil {
		if t.Elem() != elem {
			Fatalf("elem mismatch")
		}
		return t
	}

	t := New(TSLICE)
	t.Extra = Slice{Elem: elem}
	elem.Cache.slice = t
	return t
}
```

上述方法返回的结构体中的 `Extra` 字段是一个只包含切片内元素类型的结构，也就是说切片内元素的类型都是在编译期间确定的，编译器确定了类型之后，会将类型存储在 `Extra` 字段中帮助程序在运行时动态获取。

## 3.2.1 数据结构

编译期间的切片是 [`cmd/compile/internal/types.Slice`](https://draveness.me/golang/tree/cmd/compile/internal/types.Slice) 类型的，但是在运行时切片可以由如下的 [`reflect.SliceHeader`](https://draveness.me/golang/tree/reflect.SliceHeader) 结构体表示：

```go
type SliceHeader struct {
    Data uintptr
    Len int
    Cap int
}
```

- `Data`: 指向数组的指针；
- `Len`：当前切片的长度；
- `Cap`：当前切片的容量，即 `Data` 数组的大小；

 `Data` 是一片连续的内存空间，这片内存空间可以用于存储切片中的全部元素，数组中的元素只是逻辑上的概念，底层存储其实都是连续的，所以我们可以将切片理解成一片连续的内存空间加上长度和容量的标识。

![golang-slice-struct](image/2019-02-20-golang-slice-struct.png)

<center><b>图 3-3 Go 语言切片结构体</b></center>

从上图可以看出，切片和数组的关系非常密切，切片引入了一个**抽象层**，提供了对数组中部分连续片段的引用，而作为数组的引用，我们可以在运行期间修改其长度和范围。当切片底层的数组长度不足时会触发扩容，切片指向的数组可能会发生变化，不过在上层看来切片是没有变化的，上层只需要与切片打交道而不需要关心数组的变化。

## 3.2.2 初始化

Go 语言中包含三种初始化切片方式：

1. 通过下标的方式获取数组或切片的一部分；
2. 使用字面量初始化新的切片；
3. 使用关键字 `make` 创建切片；

```go
arr[0:3] or slcie[0:3]
slice := []int{1, 2, 3}
slice := make([]int, 10)
```

### 使用下标

使用下标创建切片是最原始也最接近汇编语言的方式，它是所有方法中最为底层的一种，编译器将会 `arr[0:3]` 或者 `slice[0:3]` 等语句转换成 `OpSliceMake` 操作，示例代码如下：

```go
func newSlice() []int {
	arr := [3]int{1, 2, 3}
	slice := arr[0:1]
	return slice
}
```

通过 `GOSSAFUNC` 变量编译上述代码可以得到一系列 SSA 中间代码，其中 `slice := arr[0:1]` 语句在 *decompose builtin* 阶段对应的代码如下：

```
v27 (+5) = SliceMake <[]int> v11 v14 v17

name &arr[*[3]int]: v11
name slice.ptr[*int]: v11
name slice.len[int]: v14
name slice.cap[int]: v17
```

`SliceMake` 操作会接收 4 个参数创建新的切片，元素类型、数组指针、切片大小和容量，需要注意的是使用下标初始化切片不会拷贝原数组或原切片中的数据，只会创建一个指向原数组的切片结构体，所以修改新切片的数据会影响原切片。

### 字面量

当我们使用字面量 `[]int{1, 2, 3}` 创建新的切片时，[`cmd/compile/internal/gc.slicelit`](https://draveness.me/golang/tree/cmd/compile/internal/gc.slicelit) 函数会在编译期间将其展开成如下代码片段：

```go
var vstat [3]int
vstat[0] = 1
vstat[1] = 2
vstat[2] = 3
var vauto *[3]int = new([3]int)
*vauto = vstat
slice := vauto[:]
```

1. 根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；
2. 将这些字面量元素存储到初始化的数组中；
3. 创建一个同样指向 `[3]int` 类型的数组指针；
4. 将静态存储区的数组 `vstat` 赋值给 `vauto` 指针所在的地址；
5. 通过 `[:]` 操作获取一个底层使用 `vatuo` 的切片；

第 5 步中的 `[:]` 就是使用下标创建切片的方法，可以看出 `[:]` 操作是创建切片最底层的方法。

### 关键字

如果使用字面量的方式创建切片，大部分工作将会在编译期间完成。但是当我们使用 `make` 关键字创建切片时，很多工作将会需要运行时的参与；调用方必须向 `make` 函数传入切片的大小以及可选容量，类型检查期间的  [`cmd/compile/internal/gc.typecheck1`](https://draveness.me/golang/tree/cmd/compile/internal/gc.typecheck1) 函数会校验入参：

```go
func typecheck1(n *Node, top int) (res *Node) {
	switch n.Op {
	...
	case OMAKE:
		args := n.List.Slice()

		i := 1
		switch t.Etype {
		case TSLICE:
			if i >= len(args) {
				yyerror("missing len argument to make(%v)", t)
				return n
			}

			l = args[i]
			i++
			var r *Node
			if i < len(args) {
				r = args[i]
			}
			...
			if Isconst(l, CTINT) && r != nil && Isconst(r, CTINT) && l.Val().U.(*Mpint).Cmp(r.Val().U.(*Mpint)) > 0 {
				yyerror("len larger than cap in make(%v)", t)
				return n
			}

			n.Left = l
			n.Right = r
			n.Op = OMAKESLICE
		}
	...
	}
}
```

上述函数不仅会检查 `len` 是否传入，还会保证传入的容量 `cap` 一定大于或等于 `len`。除了校验参数之外，当前函数会将 `OMAKE` 节点转换成 `OMAKESLICE`，中间代码生成的 [`cmd/compile/internal/gc.walkexpr`](https://draveness.me/golang/tree/cmd/compile/internal/gc.walkexpr) 函数会依据下面两个条件转换 `OMAKESLICE`



## Reference

1. [Go 语言设计与实现](https://draveness.me/golang) 
