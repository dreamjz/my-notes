# JWT

## 1 跨域认证问题

传统的session的认证流程如下:

	1. 用户向服务器发送用户名和密码
	2. 服务器验证通过后,将相关信息保存至session中
	3. 服务器将session ID返回给客户端并存储至cookie中
	4. 用户请求时会附上session ID,服务器会根据session ID来得知用户身份

### 1.1 传统session认证的问题

**Session**:        每个用户经过服务认证之后,会将session信息保存至内存中,当用户的数量增加时服务器的负荷会增大

**扩展性(Scaling)**: 在分布式系统中,用户需在保存其session信息的服务器中才可以获取授权,限制了应用的扩展能力

**CSRF:**           因为是基于cokkie进行识别的,若cokkie被截获,用户容易受到跨站请求攻击

### 1.2 基于Token的鉴权机制

基于token的认证和传统的session方式不同,token信息存放在客户端而不是服务端

其认证流程如下:

 	1. 用户向服务器发送用户名和密码
 	2. 服务器验证用户信息
 	3. 验证通过后向用户签发token
 	4. 用户请求时附上token,服务器验证token来进行授权

token在每次请求时发送给服务端,其应放在请求头中并要求服务端支持CORS(跨域资源共享)

## 2. JWT

JSON Web Token (JWT) is an open standard ([RFC 7519](https://tools.ietf.org/html/rfc7519)) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the **HMAC** algorithm) or a public/private key pair using **RSA** or **ECDSA**.

Although JWTs can be encrypted to also provide secrecy between parties, we will focus on *signed* tokens. Signed tokens can verify the *integrity* of the claims contained within it, while encrypted tokens *hide* those claims from other parties. When tokens are signed using public/private key pairs, the signature also certifies that only the party holding the private key is the one that signed it.

### 2.1 



## Reference

1. [jwt](https://jwt.io/introduction) jwt.io
2. [JSON Web Token 入门教程](https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html) [阮一峰](https://www.ruanyifeng.com/)
3. [jwt-go](https://pkg.go.dev/github.com/golang-jwt/jwt/v4@v4.1.0) go docs
