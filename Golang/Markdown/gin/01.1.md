# Gin Web Framework

参考 Gin 官方文档，记录学习 Gin 的笔记

## 1. Introduction

Gin is a web framework written in GO. It features a martini-like API with performance that is up to 40 times faster thanks to [httprouter](https://github.com/julienschmidt/httprouter). 

## 2. Installation 

You can use the below Go command to install Gin.

```sh
$ go get -u github.com/gin-gonic/gin
```

## 3. Quick Start 

```go
// gin-note/quick-start/main.go
package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.Default()
	router.GET("/ping", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"message": "pong",
		})
	})
	router.Run(":9090")
}
```

Run `main.go`:

```sh
$ go run ./main.go 
```

Visit `http://127.0.0.1:9090/ping`:

```sh
$ curl -X GET http://127.0.0.1:9090/ping
{"message":"pong"}
```

## 4. API Examples

You can find a number of ready-to-run examples at [Gin examples repository](https://github.com/gin-gonic/examples)(之后会单独学习这些示例)

### 4.1 Using GET,POST,PUT,PATCH,DELETE and OPTIONS

```go
// gin-note/http-methods/main.go
package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.Default()

	router.GET("/get", getting)
	router.POST("/post", posting)
	router.PUT("/put", putting)
	router.DELETE("/delete", deleting)
	router.PATCH("/patch", patching)
	router.HEAD("/head", head)
	router.OPTIONS("/option", options)

	router.Run(":9090")
}

func getting(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"message": "GET",
	})
}

func posting(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"message": "POST",
	})
}

func putting(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"message": "PUT",
	})
}

func deleting(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"message": "DELETE",
	})
}

func patching(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"message": "PATCH",
	})
}

func head(c *gin.Context) {
	c.Header("key", "val")
}

func options(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"message": "OPTION",
	})
}
```

- `gin.Default`: Creates a gin router with default middleware, logger and recovery (crash-free) middleware
- `router.Run`: By default it serves on :8080 unless a PORT environment variable was defined. You can use `router.Run(":9090")` for a hard coded port

tips:

**HTTP `HEAD` 方法** 请求资源的头部信息, 并且这些头部与 HTTP [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET) 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源

### 4.2 Parameters in path

```go
// gin-note/params-in-path/main.go
package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.Default()

	router.GET("/user/:name", hello)
	router.GET("/user/:name/*action", action)
	router.POST("/user/:name/*action", fullPath)
	router.GET("/user/groups", groups)

	router.Run(":9090")
}

func hello(c *gin.Context) {
	name := c.Param("name")
	c.String(http.StatusOK, "Hello %s", name)
}

func action(c *gin.Context) {
	name := c.Param("name")
	action := c.Param("action")
	message := name + " is " + action
	c.String(http.StatusOK, message)
}

func fullPath(c *gin.Context) {
	path := c.FullPath()
	b := path == "/user/:name/*action"
	c.String(http.StatusOK, "path: %s,%t", path, b)
}

func groups(c *gin.Context) {
	c.String(http.StatusOK, "The available groups are [...]")
}
```

- `/user/:name`: this handler will match `/user/john` but will not match `/user/` or `/user`
- `user/:name/*action`: will match `user/john/` and `/user/john/send` 
- `c.FullPath`: for each matched request `Context` will hold the route definition 
- `/user/groups`: this handler will add a new router for `/user/groups`.
  Exact routes are resolved before param routes, regardless of the order they were defined. Routes starting with `/user/groups` are never interpreted as `/user/:name/...` routes

Run `main.go` and test:

```sh
$ curl http://127.0.0.1:9090/user/kesa
Hello kesa
$ curl http://127.0.0.1:9090/user/kesa/
kesa is /
$ curl http://127.0.0.1:9090/user/kesa/send
kesa is /send
$ curl -X POST http://127.0.0.1:9090/user/kesa/
path: /user/:name/*action,true
$ curl http://127.0.0.1:9090/user/groups
The available groups are [...]
```

- `user/kesa/`将会匹配`user/:name/*action`,而不是`user/:name`
- `user/groups`优先进行精准匹配

tips:

**路由树**

在 Gin 框架中，路由规则被分成了最多 9 棵前缀树，每一个 HTTP Method对应一棵 前缀树 ，树的节点按照 URL 中的 / 符号进行层级划分，URL 支持 `:name` 形式的名称匹配，还支持 `*subpath` 形式的路径通配符

```
// 匹配单节点 named
pattern = /book/:id
match /book/123
nomatch /book/123/10
nomatch /book/

// 匹配子节点 catchAll mode
/book/*subpath
match /book/
match /book/123
match /book/123/10
```

![img](image/83dbe5dae2b018e05fdf00f636902252.jpeg)

### 4.3 QueryString parameters

```go
// gin-note/query-string-params/main.go
package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.Default()
	router.GET("/welcome", welcome)
	router.Run(":9090")
}

func welcome(c *gin.Context) {
	firstname := c.Query("firstname")
	lastname := c.Query("lastname")
	c.String(http.StatusOK, "Hello %s %s", firstname, lastname)
}

```

Run and test:

```sh
$ curl http://127.0.0.1:9090/welcome?firstname=kesa&lastname=jin
Hello kesa jin
```

### 4.4 Multipart/Urlencoded Form

```go
//
package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.Default()
	router.POST("/form_post", formPost)
	router.Run(":9090")
}

func formPost(c *gin.Context) {
	message := c.PostForm("message")
	nick := c.DefaultPostForm("nick", "anonymous")
	c.JSON(http.StatusOK, gin.H{
		"status":  "posted",
		"message": message,
		"nick":    nick,
	})
}

```

Run and test:

```sh
$ curl -X POST -d "message=hello" http://127.0.0.1:9090/form_post  
{"message":"hello","nick":"anonymous","status":"posted"}
```

tips:

**Difference between form-data and x-www-form-urlencoded**

These are different Form content types defined by W3C. If you want to send simple text/ ASCII data, then **x-www-form-urlencoded** will work. This is the default.

But if you have to send non-ASCII text or large binary data, the **form-data** is for that.

### 4.5 Query + post form

```go
// gin-note/query-and-form/main.go
package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.Default()
	router.POST("/post", details)
	router.Run(":9090")
}

func details(c *gin.Context) {
	id := c.Query("id")
	page := c.DefaultQuery("page", "0")
	message := c.PostForm("message")
	name := c.PostForm("name")
	c.JSON(http.StatusOK, gin.H{
		"id":      id,
		"page":    page,
		"name":    name,
		"message": message,
	})
}

```

Run and test:

```sh
$ curl -X POST -d "message=hello&name=kesa" http://127.0.0.1:9090/post\?id\=1\&page\=1
{"id":"1","message":"hello","name":"kesa","page":"1"}
```

### 4.6 Map as querystring or postform parameters

```go
// gin-note/map-as-param/main.go
package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.Default()
	router.POST("/post", post)
	router.Run(":9090")
}

func post(c *gin.Context) {
	ids := c.QueryMap("ids")
	names := c.PostFormMap("names")
	c.JSON(http.StatusOK, gin.H{
		"ids":   ids,
		"names": names,
	})
}
```

Run and test :

```sh
$ curl -X POST -d "names[first]=kesa&names[second]=jin" -g "http://127.0.0.1:9090/post?ids[a]=1&ids[b]=2"
{"ids":{"a":"1","b":"2"},"names":{"first":"kesa","second":"jin"}}
```

tips:

curl 发送请求时要使用`-g` 以禁用网址序列和范围使用{}和[]，否则参数中带有`{},[]`将会报错

### 4.7 Upload files

#### Single file

`file.Filename` **SHOULD NOT** be trusted. See [`Content-Disposition` on MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition#Directives) and [#1693](https://github.com/gin-gonic/gin/issues/1693)

>The filename is always optional and must not be used blindly by the application: path information should be stripped, and conversion to the server file system rules should be done.

```go
// gin-note/upload-single-file/main.go
package main

import (
	"fmt"
	"log"
	"net/http"
	"path/filepath"

	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.Default()
	router.MaxMultipartMemory = 8 << 20 // 8 MiB
	router.POST("/upload", upload)
	router.Run(":9090")
}

func upload(c *gin.Context) {
	file, _ := c.FormFile("file")
	log.Println(file.Filename)
	dst := filepath.Base(file.Filename)
	log.Println("dst:", dst)
	c.SaveUploadedFile(file, dst)
	c.String(http.StatusOK, fmt.Sprintf("%s uploaded", file.Filename))
}

```

- `router.MaxMultipartMemory = 8 << 20`: Set a lower memory limit for multipart forms (default is 32 MiB)

Run and test:

```sh
$ curl -X POST http://127.0.0.1:9090/upload -F "file=@test.txt" \    
-H "Content-Type: multipart/form-data"
test.txt uploaded
```

**注意**

这里特别强调不要信任任何用户定义的文件名，非常危险[#1693](https://github.com/gin-gonic/gin/issues/1693)

比如用户设定用户名为`../test.txt`,可以改变存储的位置，或者文件名为 html 标签，这样都是非常危险的

简单的处理方案是使用`filepath.Base`过滤文件名（`../text.txt`->`text.txt`）,但这样仍有安全隐患，应该自定义文件名,比如

```go
now := time.Now().Format("20060102150405")
dst := fmt.Sprintf("%s_%s", username, now)
```

#### Multiple files

```go
// gin-note/upload-multiple-files/main.go
package main

import (
	"fmt"
	"log"
	"net/http"
	"path/filepath"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.Default()
	router.MaxMultipartMemory = 8 << 20
	router.POST("/upload", upload)
	router.Run(":9090")
}

func upload(c *gin.Context) {
	form, _ := c.MultipartForm()
	files := form.File["upload[]"]
	username := c.Query("username")
	for _, file := range files {
		log.Println(file.Filename)
		extension := filepath.Ext(file.Filename)
		filename := strings.TrimSuffix(file.Filename, extension)
		now := time.Now().Format("20060102150405")
		dst := fmt.Sprintf("%s_%s_%s%s", now, username, filename, extension)
		c.SaveUploadedFile(file, dst)
	}
	c.String(http.StatusOK, fmt.Sprintf("%d files uploaded", len(files)))
}
```

Run and test:

```sh
$ curl -X POST "http://127.0.0.1:9090/upload?username=kesa" \   
-F "upload[]=@test.txt" \
-F "upload[]=@test1.txt" \
-F "upload[]=@test2.txt" \
-H "Content-Type: multipart/form-data"
3 files uploaded
```

### 4.8 Grouping routes

```go
// gin-note/grouping-routes/main.go
package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.Default()
	v1 := router.Group("/v1")
	{
		v1.GET("/get", v1Get)
	}
	v2 := router.Group("/v2")
	{
		v2.GET("/get", v2Get)
	}
	router.Run(":9090")
}

func v1Get(c *gin.Context) {
	c.String(http.StatusOK, "V1 GET ")
}

func v2Get(c *gin.Context) {
	c.String(http.StatusOK, "V2 GET ")
}
```

Run and test:

```sh
$ curl "http://127.0.0.1:9090/v1/get"
V1 GET 
$ curl "http://127.0.0.1:9090/v2/get"
V2 GET          
```

### 4.9 Using middleware

#### Blank Gin without middleware by default

Use

```go
router := gin.New()
```

instead of 

```go
// Default with the Logger and Recovery middleware already attached
router := gin.Default()
```

#### Using middleware

```go
// gin-note/using-middleware/main.go
package main

import (
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.New()
	router.Use(gin.Logger())
	router.Use(gin.Recovery())
	router.Use(MyGlobalMiddleware())

	router.GET("/req", func(c *gin.Context) {
		middleware := c.MustGet("middleware")
		c.String(http.StatusOK, fmt.Sprintf("Middleware type: %s", middleware))
	})

	router.GET("/req1", MyRouteMiddleware(), func(c *gin.Context) {
		middleware := c.MustGet("middleware")
		c.String(http.StatusOK, fmt.Sprintf("Middleware type: %s", middleware))
	})

	grp := router.Group("/grp")
	grp.Use(MyGroupMiddleware())
	{
		grp.GET("/req", func(c *gin.Context) {
			middleware := c.MustGet("middleware")
			c.String(http.StatusOK, fmt.Sprintf("Middleware type: %s", middleware))
		})
	}

	router.Run(":9090")
}

func MyGlobalMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Set("middleware", "global")
		fmt.Println("[Global] Before request")
		c.Next()
		fmt.Println("[Global] After request")
	}
}

func MyRouteMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Set("middleware", "route")
		fmt.Println("[Route] Before request")
		c.Next()
		fmt.Println("[Route] After request")
	}
}

func MyGroupMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Set("middleware", "group")
		fmt.Println("[Group] Before request")
		c.Next()
		fmt.Println("[Group] After request")
	}
}
```

- `router.Use(gin.Logger())`: Global middleware, Logger middleware will write the logs to gin.DefaultWrite even if you set with GIN_MODE=release, by default gin.DefaultWriter = os.Stdout
- `router.Use(gin.Recovery())`: Recovery middleware recovers from any panics and writes a 500(http code) if there was one
- `router.GET("/req1", MyRouteMiddleware(), func(c *gin.Context){...})`: Per route middleware, you can add as many as you desire
- `grp.Use(MyGroupMiddleware())`: Per group middleware, use custom middleware just in this group

Run and test:

```sh
$ curl -X GET "http://127.0.0.1:9090/req" 
Middleware type: global
$ curl -X GET "http://127.0.0.1:9090/req1"
Middleware type: route
$ curl -X GET "http://127.0.0.1:9090/grp/req"
Middleware type: group
```

tips:

调用`/grp/req`的时候，日志如下：

```
2021/11/18 09:58:30 [Global] Before request
2021/11/18 09:58:30 [Group] Before request
2021/11/18 09:58:30 [Group] After request
2021/11/18 09:58:30 [Global] After request
```

可以看到不同层级的 middleware 会按照后进先出(栈)的顺序调用

#### Custom Recovery behavior

```go
// gin-note/custom-recovery/main.go
package main

import (
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.New()
	router.Use(gin.Logger())
	router.Use(gin.CustomRecovery(func(c *gin.Context, recovered interface{}) {
		if err, ok := recovered.(string); ok {
			c.String(http.StatusInternalServerError, fmt.Sprintf("error: %s", err))
		}
		c.AbortWithStatus(http.StatusInternalServerError)
	}))

	router.GET("/panic", func(c *gin.Context) {
		panic("foo")
	})

	router.GET("/", func(c *gin.Context) {
		c.String(http.StatusOK, "ohai")
	})

	router.Run(":9090")
}
```

Run and test:

```sh
$ curl -X GET "http://127.0.0.1:9090/"       
ohai%                                                                 $ curl -X GET "http://127.0.0.1:9090/panic"  
error: foo
```

#### Custom Log Format

```go
// gin-note/custom-log-format/main.go
package main

import (
	"fmt"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

func main() {
	router := gin.New()

	router.Use(gin.LoggerWithFormatter(func(params gin.LogFormatterParams) string {
		return fmt.Sprintf("%s - [%s] \"%s %s %s %d %s \"%s\"%s \n",
			params.ClientIP,
			params.TimeStamp.Format(time.RFC1123),
			params.Method,
			params.Path,
			params.Request.Proto,
			params.StatusCode,
			params.Latency,
			params.Request.UserAgent(),
			params.ErrorMessage)
	}))
	router.Use(gin.Recovery())

	router.GET("/ping", func(c *gin.Context) {
		c.String(http.StatusOK, "pong")
	})

	router.Run(":9090")
}

```

Run and test:

```sh
$ curl -X GET "http://127.0.0.1:9090/ping" 
pong
```

log:

```
127.0.0.1 - [Thu, 18 Nov 2021 13:24:09 CST] "GET /ping HTTP/1.1 200 65.781µs "curl/7.79.1" 
```

#### How to write log file

```go
package main

import (
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"

	"github.com/gin-gonic/gin"
)

type Login struct {
	User     string `form:"user" json:"user" xml:"user" binding:"required"`
	Password string `form:"password" json:"password" xml:"password" binding:"required"`
}

func main() {
	f, err := createLogFile("./log/gin.log")
	if err != nil {
		log.Fatal("create log file failed:", err)
	}
	defer f.Close()
	gin.DefaultWriter = io.MultiWriter(f, os.Stdout)
	router := gin.Default()
	router.GET("/ping", func(c *gin.Context) {
		c.String(http.StatusOK, "pong")
	})
	log.Println("Listen and serve on 0.0.0.0:9090")
	router.Run(":9090")
}

func createLogFile(path string) (*os.File, error) {
	dir := filepath.Dir(path)
	log.Println("dir is: ", dir)
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		err = os.MkdirAll(path, 0755)
		if err != nil {
			log.Fatal("create dir failed:", err)
		}
	}
	return os.Create(path)
}
```

- `gin.DefaultWriter = io.MultiWriter(f, os.Stdout)`: write the logs to file and console at the same time

Run and test:

```sh
$ curl -X GET "http://0.0.0.0:9090/ping"
pong
```

#### Controlling Log output coloring

By default, logs output on console should be colorized depending on the detected TTY.

Never colorize logs:

```go
// gin-note/colorize-log/main.go
package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	gin.DisableConsoleColor()
	router := gin.Default()
	router.GET("/ping", func(c *gin.Context) {
		c.String(http.StatusOK, "pong")
	})

	router.Run(":9090")
}
```

Always colorize logs:

```go
// gin-note/colorize-log/main.go
package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	gin.ForceConsoleColor()
	router := gin.Default()
	router.GET("/ping", func(c *gin.Context) {
		c.String(http.StatusOK, "pong")
	})

	router.Run(":9090")
}
```

### 4.10 Model binding and validation

To bind a request body into a type, use model binding. We currently support binding of JSON, XML, YAML and standard form values (foo=bar&boo=baz).

Gin use  [**go-playground/validator/v10**](https://github.com/go-playground/validator) for validation. Check the full docs on tags usage  [here](https://godoc.org/github.com/go-playground/validator#hdr-Baked_In_Validators_and_Tags).

Also, Gin provides two sets of methods for binding:

- Type - Must bind
  - Methods - `Bind`, `BindJSON`, `BindXML`, `BindQuery`, `BindYAML`, `BindHeader`
  - Behavior - These methods use `MustBindWith` under the hood. If there is a binding error, the request is aborted with `c.AbortWithError(400,err).SetType(ErrorTypeBind)`. This sets the response status code to 400 and the `Content-Type` header is set to `text/plain;charset=utf-8`. Note that if you try to set the response code after this, it will result in a warning `[GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422`. If you wish to have greater control over the behavior, consider using the `ShouldBind` equivalent method.
- Type - Should bind
  - Methods - `ShouldBind`, `ShouldBindJSON`, `ShouldBindXML`, `ShouldBindQuery`, `ShouldBindYAML`, `ShouldBindHeader`
  - Behavior - These methods use `ShouldBindWith` under the hood. If there is a binding error, the error is returne and it is the developer's responsibilty to handle the request and error appropriately.

When using the Bind-method, Gin tries to infer the binder depending on the Content-Type header. If you are sure what you are binding, you can use `MustBindWith` or `ShouldBindWith`.

You can also specify the specific fields are required. If a field is decorated with `binding:"required"` and has a empty value when binding, an error will be returned.

```go
// gin-note/bind-and-validation/main.go
package main

import (
	"log"
	"net/http"

	"github.com/gin-gonic/gin"
)

type Login struct {
	User     string `form:"user" json:"user" xml:"user" binding:"required"`
	Password string `form:"password" json:"password" xml:"password" binding:"required"`
}

func main() {
	router := gin.Default()
	router.POST("/loginJSON", loginJSON)
	router.POST("/loginXML", loginXML)
	router.POST("/loginForm", loginForm)
	log.Println("Listen and serve on 0.0.0.0:8080")
	router.Run(":9090")
}

func loginJSON(c *gin.Context) {
	var json Login
	if err := c.ShouldBindJSON(&json); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}
	if json.User != "menu" || json.Password != "123" {
		c.JSON(http.StatusUnauthorized, gin.H{
			"status": "unauthorized",
		})
		return
	}
	c.JSON(http.StatusOK, gin.H{
		"status": "you are logged in",
	})
}

func loginXML(c *gin.Context) {
	var xml Login
	if err := c.ShouldBindXML(&xml); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}
	if xml.User != "menu" || xml.Password != "123" {
		c.JSON(http.StatusUnauthorized, gin.H{
			"status": "unauthorized",
		})
		return
	}
	c.JSON(http.StatusOK, gin.H{
		"status": "you are logged in",
	})
}

func loginForm(c *gin.Context) {
	var form Login
	if err := c.ShouldBind(&form); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}
	if form.User != "menu" || form.Password != "123" {
		c.JSON(http.StatusUnauthorized, gin.H{
			"status": "unauthorized",
		})
		return
	}
	c.JSON(http.StatusOK, gin.H{
		"status": "you are logged in",
	})
}
```

Run and test:

```sh
$ curl -X POST "http://0.0.0.0:9090/loginJSON" \
-d '{"user":"menu","password":"123"}'
{"status":"you are logged in"}
$ curl -X POST "http://0.0.0.0:9090/loginXML" \ 
-d '<?xml version="1.0" encode="UTF-8"?><root><user>menu</user><password>123</password></root>'
{"status":"you are logged in"}
$  curl -X POST "http://0.0.0.0:9090/loginForm" \
-d 'user=menu&password=123'
{"status":"you are logged in"}
```

tips:

**对于 form 数据使用了 `ShouldBind`**

JSON 和 XML 类型的数据有对应的方法 `ShouldBindJSON` 和 `ShouldBindXML`，那是对于 FORM 数据使用的是 `ShouldBind`

`ShouldBind`的描述是：

> ShouldBind checks the Content-Type to select a binding engine automatically,
> Depending the "Content-Type" header different bindings are used:
>     "application/json" --> JSON binding
>     "application/xml"  --> XML binding
>otherwise --> returns an error
> It parses the request's body as JSON if Content-Type == "application/json" using JSON or XML as a JSON input.
> It decodes the json payload into the struct specified as a pointer.
> Like c.Bind() but this method does not set the response status code to 400 and abort if the json is not valid.

可以看到 `ShouldBind` 可以自动根据数据类型选择不同额绑定方式，这个自动绑定是如何实现的呢~

这里看下源码, `ShouldBind`:

```go
func (c *Context) ShouldBind(obj interface{}) error {
	b := binding.Default(c.Request.Method, c.ContentType())
	return c.ShouldBindWith(obj, b)
}
```

`binding.Default`:

```go
func Default(method, contentType string) Binding {
	if method == http.MethodGet {
		return Form
	}

	switch contentType {
	case MIMEJSON:
		return JSON
	case MIMEXML, MIMEXML2:
		return XML
	case MIMEPROTOBUF:
		return ProtoBuf
	case MIMEMSGPACK, MIMEMSGPACK2:
		return MsgPack
	case MIMEYAML:
		return YAML
	case MIMEMultipartPOSTForm:
		return FormMultipart
	default: // case MIMEPOSTForm:
		return Form
	}
}
```

```go
const (
	MIMEJSON              = "application/json"
	MIMEHTML              = "text/html"
	MIMEXML               = "application/xml"
	MIMEXML2              = "text/xml"
	MIMEPlain             = "text/plain"
	MIMEPOSTForm          = "application/x-www-form-urlencoded"
	MIMEMultipartPOSTForm = "multipart/form-data"
	MIMEPROTOBUF          = "application/x-protobuf"
	MIMEMSGPACK           = "application/x-msgpack"
	MIMEMSGPACK2          = "application/msgpack"
	MIMEYAML              = "application/x-yaml"
)
```

这里会根据请求头中的 `Content-Type` 来决定绑定数据的方式，前文也提到了`ShouldBind`类的方法底层均会调用 `ShouldBindWith`, `ShouldBindJSON` 和 `ShouldBindXML` 相较于 `ShouldBind` 来说只是将绑定的类型固定下来而已

```go
// ShouldBindXML is a shortcut for c.ShouldBindWith(obj, binding.XML).
func (c *Context) ShouldBindXML(obj interface{}) error {
	return c.ShouldBindWith(obj, binding.XML)
}
// ShouldBindJSON is a shortcut for c.ShouldBindWith(obj, binding.JSON).
func (c *Context) ShouldBindJSON(obj interface{}) error {
	return c.ShouldBindWith(obj, binding.JSON)
}
```

ShouldBindXXX 只是 `ShouldBindWith`的简短写法，这里没有提供  `ShouldBindForm`

#### Skip validate

When running the above example using the above the `curl` command, it returns error. Because the example use `binding:"required"` for `Password`. If using `binding:"-"` for `Password`, then it will not return error when running the above example again.

#### Custom Validators

It is also possible to register custom validators.

```go
// gin-note/custom-validator/main.go
package main

import (
	"log"
	"net/http"
	"time"

	"github.com/gin-gonic/gin/binding"

	"github.com/go-playground/validator/v10"

	"github.com/gin-gonic/gin"
)

type Booking struct {
	CheckIn  time.Time `form:"checkin" binding:"required,bookableDate" time_format:"2006-01-02"`
	CheckOut time.Time `form:"checkout" binding:"required,gtfield=CheckIn" time_format:"2006-01-02"`
}

var bookableDate validator.Func = func(fl validator.FieldLevel) bool {
	date, ok := fl.Field().Interface().(time.Time)
	if ok {
		today := time.Now()
		if today.After(date) {
			return false
		}
	}
	return true
}

func main() {
	router := gin.Default()
	if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
		v.RegisterValidation("bookableDate", bookableDate)
	}
	router.GET("/bookable", getBookable)
	log.Println("Listen and serve on 0.0.0.0:9090")
	router.Run(":9090")
}

func getBookable(c *gin.Context) {
	var b Booking
	if err := c.ShouldBindWith(&b, binding.Query); err == nil {
		c.JSON(http.StatusOK, gin.H{
			"message": "Booking dates are valid",
		})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
	}
}

```

- `gtfield=CheckIn`： 当前 field (Checkout) 需要比 CheckIn（此处大小写敏感） 大
- `time_format`: 指定时间格式，若不符合将会报错

Run and test:

```sh
$ curl "http:/127.0.0.1:9090/bookable?checkin=2030-06-20&checkout=2030-06-30"
{"message":"Booking dates are valid"}
$ curl "http:/127.0.0.1:9090/bookable?checkin=2000-06-20&checkout=2030-06-30"
{"error":"Key: 'Booking.CheckIn' Error:Field validation for 'CheckIn' failed on the 'bookableDate' tag"}
$ curl "http:/127.0.0.1:9090/bookable?checkin=2030-06-20&checkout=2011-06-30"
{"error":"Key: 'Booking.CheckOut' Error:Field validation for 'CheckOut' failed on the 'gtfield' tag"}
$ curl -G "http:/127.0.0.1:9090/bookable" --data-urlencode "checkin=2030-06-20&checkout=2030-06-30 11:20:11"
{"error":"parsing time \"2030-06-20\u0026checkout=2030-06-30 11:20:11\": extra text: \"\u0026checkout=2030-06-30 11:20:11\""}
```

注意： `-G`:使用 GET 发送数据，加上 `--data-urlencode`, 将参数进行编码后以 Query String 的形式发送，`2030-06-30 11:20:11`中含有空格，若不进行编码将无法识别

tips：

使用 `ShouldBindWith(&b,binding.Query)` ，结构体的字段标签需要使用`form`才可以绑定，可以看下源码：

`ShouldBindWith`:

```go
func (c *Context) ShouldBindWith(obj interface{}, b binding.Binding) error {
   return b.Bind(c.Request, obj)
}
```

`Binding`一个接口，其`Bind`方法定义了绑定数据行为：

```go
type Binding interface {
	Name() string
	Bind(*http.Request, interface{}) error
}
```

`binding.Query`是实现了`Binding`接口：

```go
func (queryBinding) Bind(req *http.Request, obj interface{}) error {
	values := req.URL.Query()
	if err := mapForm(obj, values); err != nil {
		return err
	}
	return validate(obj)
}
```

接着追踪代码：

```go
func mapForm(ptr interface{}, form map[string][]string) error {
	return mapFormByTag(ptr, form, "form")
}

func mapFormByTag(ptr interface{}, form map[string][]string, tag string) error {
	// Check if ptr is a map
	ptrVal := reflect.ValueOf(ptr)
	var pointed interface{}
	if ptrVal.Kind() == reflect.Ptr {
		ptrVal = ptrVal.Elem()
		pointed = ptrVal.Interface()
	}
	if ptrVal.Kind() == reflect.Map &&
		ptrVal.Type().Key().Kind() == reflect.String {
		if pointed != nil {
			ptr = pointed
		}
		return setFormMap(ptr, form)
	}

	return mappingByPtr(ptr, formSource(form), tag)
}

func mappingByPtr(ptr interface{}, setter setter, tag string) error {
	_, err := mapping(reflect.ValueOf(ptr), emptyField, setter, tag)
	return err
}
```

可以看到 Query 实际上使用了 `form` 标签进行数据的绑定，接着看`mapping`函数：

```go
func mapping(value reflect.Value, field reflect.StructField, setter setter, tag string) (bool, error) {
	if field.Tag.Get(tag) == "-" { // just ignoring this field
		return false, nil
	}

	var vKind = value.Kind()

	if vKind == reflect.Ptr {
		var isNew bool
		vPtr := value
		if value.IsNil() {
			isNew = true
			vPtr = reflect.New(value.Type().Elem())
		}
		isSetted, err := mapping(vPtr.Elem(), field, setter, tag)
		if err != nil {
			return false, err
		}
		if isNew && isSetted {
			value.Set(vPtr)
		}
		return isSetted, nil
	}

	if vKind != reflect.Struct || !field.Anonymous {
		ok, err := tryToSetValue(value, field, setter, tag)
		if err != nil {
			return false, err
		}
		if ok {
			return true, nil
		}
	}

	if vKind == reflect.Struct {
		tValue := value.Type()

		var isSetted bool
		for i := 0; i < value.NumField(); i++ {
			sf := tValue.Field(i)
			if sf.PkgPath != "" && !sf.Anonymous { // unexported
				continue
			}
			ok, err := mapping(value.Field(i), tValue.Field(i), setter, tag)
			if err != nil {
				return false, err
			}
			isSetted = isSetted || ok
		}
		return isSetted, nil
	}
	return false, nil
}
```

利用了反射机制，将 Query String 的参数绑定到结构体中，会忽略掉标签为`form:"-"`的字段 

#### Struct Level Validation

```go
package main

import (
	"log"
	"net/http"

	"github.com/gin-gonic/gin/binding"

	"github.com/go-playground/validator/v10"

	"github.com/gin-gonic/gin"
)

type User struct {
	Firstname string `json:"firstname"`
	Lastname  string `json:"lastname"`
	Email     string `binding:"required,email"`
}

func UserStructLevelValidation(sl validator.StructLevel) {
	user := sl.Current().Interface().(User)
	if len(user.Firstname) == 0 && len(user.Lastname) == 0 {
		sl.ReportError(user.Firstname, "Firstname", "Firstname", "FirstnameOrLastname", "")
		sl.ReportError(user.Lastname, "Lastname", "Lastname", "FirstnameOrLastname", "")
	}

}

func main() {
	router := gin.Default()
	if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
		v.RegisterStructValidation(UserStructLevelValidation, User{})
	}
	router.POST("/user", validateUser)
	log.Println("Listen and serve on 0.0.0.0:9090")
	router.Run(":9090")
}

func validateUser(c *gin.Context) {
	var user User
	if err := c.ShouldBindJSON(&user); err == nil {
		c.JSON(http.StatusOK, gin.H{
			"message": "User validation successful",
		})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{
			"message": "User validation failed",
			"error":   err.Error(),
		})
	}
}
```

Run and test:

```sh
$ curl -X POST "http://127.0.0.1:9090/user" -d '{"firstname":"A","lastname":"B","email":"xx@yy.com"}'
{"message":"User validation successful"}
$ curl -X POST "http://127.0.0.1:9090/user" -d '{"email":"xx@yy.com"}' 
{"error":"Key: 'User.Firstname' Error:Field validation for 'Firstname' failed on the 'FirstnameOrLastname' tag\nKey: 'User.Lastname' Error:Field validation for 'Lastname' failed on the 'FirstnameOrLastname' tag","message":"User validation failed"}
```

#### Only Bind Query String

`ShouldBindQuery` function only binds the query params and not the post data.

```go
package main

import (
	"log"
	"net/http"

	"github.com/gin-gonic/gin"
)

type Person struct {
	Name    string `form:"name"`
	Address string `form:"address"`
}

func main() {
	router := gin.Default()
	router.Any("/test", startPage)
	log.Println("Listen and serve on 0.0.0.0:9090")
	router.Run(":9090")
}

func startPage(c *gin.Context) {
	var p Person
	if c.ShouldBindQuery(&p) == nil {
		log.Println("===== Only Bind Query String =====")
		log.Println(p.Name)
		log.Println(p.Address)
	}
	c.String(http.StatusOK, "Success")

}
```

Run and test:

```sh
$ curl -X GET "http://0.0.0.0:9090/test?name=kesa&address=xyz"
Success
$ curl -X POST "http://0.0.0.0:9090/test?name=kesa&address=xyz" -d "name=ingnore&address=ignore"
Success
```

log:

```
[GIN-debug] Listening and serving HTTP on :9090
2021/11/22 02:29:29 ===== Only Bind Query String =====
2021/11/22 02:29:29 kesa
2021/11/22 02:29:29 xyz
[GIN] 2021/11/22 - 02:29:29 | 200 |     115.852µs |       127.0.0.1 | GET      "/test?name=kesa&address=xyz"
2021/11/22 02:30:19 ===== Only Bind Query String =====
2021/11/22 02:30:19 kesa
2021/11/22 02:30:19 xyz
[GIN] 2021/11/22 - 02:30:19 | 200 |      40.661µs |       127.0.0.1 | POST     "/test?name=kesa&address=xyz"
```

可以看到仅绑定了 query string 数据

tips：

`ShouldBindQuery`是`ShouldBindWith(obj,binding.Query)`的简写，`binding.Query`实现了`Binding`接口，其`Bind`方法：

```go
func (queryBinding) Bind(req *http.Request, obj interface{}) error {
	values := req.URL.Query()
	if err := mapForm(obj, values); err != nil {
		return err
	}
	return validate(obj)
}
```

可以看到，数据来源使用了`req.URL.Query`获取，即仅绑定了 Query String 的数据

 #### Bind Query String or Post Data



## Reference

1. [gin](https://github.com/gin-gonic/gin) github
2. [HTTP HEAD](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD) MDN Web Docs
3. [gin框架总结](https://studygolang.com/articles/32543) studygolang
4. [Postman Chrome: What is the difference between form-data, x-www-form-urlencoded and raw](https://stackoverflow.com/questions/26723467/postman-chrome-what-is-the-difference-between-form-data-x-www-form-urlencoded) stackoverflow
5. [Forms in HTML documents](https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1) 
