---
title: Gin搭建Blog API (1)
date: '2021-11-08'
categories:
 - 'golang'
tags:
 - 'gin'
publish: true
---

# Gin搭建Blog API

## 初始化

### 项目目录

创建项目目录`go-gin-example`,并添加以下目录：

```
go-gin-example
├── api
├── conf
├── global
├── core
├── middleware
├── models
├── routers
├── runtime
├── service
└── utils
```

- api : 路由处理逻辑
- conf : 用于存储配置文件
- middleware : 应用中间件
- models : 应用数据库模型
- global : 全局变量，viper, gorm 等
- routers : 路由逻辑处理
- runtime : 应用运行时数据
- core : 应用核心组件
- service : 数据库访问
- utils : 工具包

这里将原项目中的`pkg`改为`global`，将需要全局调用的变量存放于此，如 viper,gorm 等

### go modules

进入`go-gin-example`,执行：

```sh
go mod init go-gin-example
```

添加依赖：

```
go get github.com/gin-gonic/gin@latest
```

这里没有在`go.mod`中使用`replace`，因为自己实践的这个项目不是独立的 github 仓库，无需使用远程包，使用本地包即可

go modules replace 的使用场景可以参考 [Go Module’s Replace](https://levelup.gitconnected.com/go-modules-replace-3ea6d0139c91)

### 初始化数据库

创建文件`blog_init.sql`并写入：

```sql
-- 若不存在则创建数据库 blog, 字符编码为 utf8, 校验规则为 utf8_general_ci 不区分大小写
CREATE DATABASE IF NOT EXISTS blog CHARSET utf8 COLLATE utf8_general_ci;
-- 进入数据库 blog
USE `blog`;
-- 标签表
CREATE TABLE IF NOT EXISTS `blog_tag` (
	`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `name` varchar(100) DEFAULT '' COMMENT '标签名称',
    `state` tinyint(3) unsigned DEFAULT '1' COMMENT '状态 0 禁用，1 启用',
    `created_by` varchar(100) DEFAULT  '' COMMENT '创建人', 
    `updated_by` varchar(100) DEFAULT '' COMMENT '修改人',
    `created_at` datetime,
    `updated_at` datetime,
    `deleted_at` datetime,
    PRIMARY KEY (id)
)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '文章标签管理';
-- 文章表
CREATE TABLE IF NOT EXISTS `blog_article` (
	`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `tag_id` int(10) unsigned DEFAULT '0' COMMENT 'tag id',
    `title` varchar(100) DEFAULT '' COMMENT '文章标题',
    `description` varchar(255) DEFAULT '' COMMENT '文章描述',
    `content` text COMMENT '文章内容',
    `state` tinyint(3) unsigned DEFAULT '1' COMMENT '状态 0 禁用，1 启用',
    `created_by` varchar(100) DEFAULT '' COMMENT '创建人',
   	`updated_by` varchar(100) DEFAULT '' COMMENT '修改人',
    `created_at` datetime,
    `updated_at` datetime,
    `deleted_at` datetime,
    PRIMARY KEY (id)
)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '文章管理';
-- 认证表
CREATE TABLE IF NOT EXISTS `blog_auth` (
	`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `username` varchar(50) DEFAULT '' COMMENT '用户名',
    `password` varchar(50) DEFAULT '' COMMENT '密码',
    `created_by` varchar(100) DEFAULT '' COMMENT '创建人',
    `updated_by` varchar(100) DEFAULT '' COMMENT '修改人',
    `created_at` datetime,
    `updated_at` datetime,
    `deleted_at` datetime,
    PRIMARY KEY (id)
)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '认证管理';
-- 插入 admin
INSERT INTO `blog`.`blog_auth` (`username`,`password`,`created_at`) VALUES ('admin','admin',NOW());
```

原项目使用的`gorm`版本为`v0.0.0`,当前`gorm`版本为`v1.2.2`(`gorm`在`v1.2.0`版本进行重构)，由于此原因此处将表结构稍作改变

登入 Mysql ：

```sh
mysql -u root -p
```

执行脚本：

```sh
source $HOME/golang-notes/go-gin-example/blog_init.sql
```

## 项目配置

### 引入 viper

原项目使用的是`go-ini`用于读取`ini`配置，这里我使用`viper`进行配置读取

在项目根目录(go.mod所在目录)执行：

```go
go get 
```



### 配置文件

在`conf`目录下创建配置文件`config.yml`,写入以下内容:

```yaml
# debug or release
run-mode: debug
# application
app:
  page-size: 10
  jwt-secret: 23347$040412
# server
server:
  http-port: 9090
  read-timeout: 60s
  write-timeout: 60s
# database
database:
  type: mysql
  user: username
  password: password
  host: 127.0.0.1
  port: 3306
  name: blog
  table-prefix: blog_
```

### 配置结构体

在`global`目录下创建`global.go`：

```go
package global

import "go-gin-example/models/config"

var (
	AppConfig config.Config
)

```

在`models`创建`config`文件夹，配置相关的相关的结构体放在这里：

创建`config.go`并写入：

```go
package config

type Config struct {
	RunMode  string   `mapstructure:"run-mode"`
	App      App      `mapstructure:"app"`
	Server   Server   `mapstructure:"server"`
	Database Database `mapstructure:"database"`
}
```

`app.go` :

```go
package config

type App struct {
	PageSize  int    `mapstructure:"page-size"`
	JwtSecret string `mapstructure:"jwt-secret"`
}
```

`server.go` :

```go
package config

type Server struct {
	HttpPort     string `mapstructure:"http-port"`
	ReadTimeout  time.Duration    `mpstructure:"read-timeout"`
	WriteTimeout time.Duration    `mapstructure:"write-timeout"`
}
```

`database.go` : 

```go
package config

type Database struct {
	Type        string `mapstructure:"type"`
	User        string `mapstructure:"user"`
	Password    string `mapstructure:"password"`
	Host        string `mapstructure:"host"'`
	Port        int    `mapstructure:"port"`
	Name        string `mapstructure:"name"`
	TablePrefix string `mapstructure:"table-prefix"`
}
```

### 初始化 viper

在 `core` 目录下创建`viper.go`并写入：

```go
package core

import (
	"fmt"
	"github.com/fsnotify/fsnotify"
	"github.com/spf13/viper"
	"go-gin-example/global"
	"log"
)

func Viper() {
	viper.SetConfigName("config")
	viper.SetConfigType("yaml")
	viper.AddConfigPath("./conf")
	err := viper.ReadInConfig()
	if err != nil {
		panic(fmt.Errorf("fatal error config file : %w \n", err))
	}
	// watching and re-reading config files
	viper.OnConfigChange(func(e fsnotify.Event) {
		log.Printf("Config file changed, name:%s, op:%s", e.Name, e.Op)
		err = viper.Unmarshal(&global.AppConfig)
		if err != nil {
			log.Printf("Re-reading config failed, %v", err)
		}
	})
	viper.WatchConfig()
	// decode config into struct
	err = viper.Unmarshal(&global.AppConfig)
	if err != nil {
		log.Fatalf("Unable decode config into struct, %v ", err)
	}
}

```

现在的目录结构：

```
go-gin-example
├── conf
│   └── config.yml
├── core
│   └── viper.go
├── global
│   └── global.go
├── middleware
├── models
│   └── config
│       ├── app.go
│       ├── config.go
│       ├── database.go
│       └── server.go
├── routers
├── runtime
├── go.mod
├── go.sum
└── main.go
```

## API错误码

在`models`中新增`response`目录，创建`code.go`并写入：

```go
package response

const (
	Success       = 200
	Error         = 500
	InvalidParams = 400

	ErrorExistTag        = 10001
	ErrorNotExistTag     = 10002
	ErrorNotExistArticle = 10003

	ErrorAuthCheckTokenFail    = 20001
	ErrorAuthCheckTokenTimeout = 20002
	ErrorAuthToken             = 20003
	ErrorAuth                  = 20004
)
```

关于常量的命名，原项目中使用全大写加下划线的形式(ALL_CAPS)，这里采用驼峰命名，和标准库的命名类似（参考：[Go naming conventions for const](https://stackoverflow.com/questions/22688906/go-naming-conventions-for-const)）

配置错误信息，`msg.go`:

```go
package response

var msgFlags = map[int]string{
	Success:                    "ok",
	Error:                      "fail",
	InvalidParams:              "request parameters error",
	ErrorExistTag:              "tag already exists",
	ErrorNotExistTag:           "tag not exists",
	ErrorNotExistArticle:       "article not exists",
	ErrorAuthCheckTokenFail:    "check token failed",
	ErrorAuthCheckTokenTimeout: "token timeout",
	ErrorAuthToken:             "token generate failed",
	ErrorAuth:                  "token error",
}

func GetMsg(code int) string {
	msg, ok := msgFlags[code]
	if ok {
		return msg
	}
	return msgFlags[Error]
}
```

注意这里的map不能是`const`,常量只能是数字，字符，字符串和布尔值

>Constants in Go are just that—constant. They are created at compile time, even when defined as locals in functions, and can only be numbers, characters (runes), strings or booleans. Because of the compile-time restriction, the expressions that define them must be constant expressions, evaluatable by the compiler. For instance, 1<<3 is a constant expression, while math.Sin(math.Pi/4) is not because the function call to math.Sin needs to happen at run time.

可以参考[effective go](http://golang.org/doc/effective_go.html#constants)和[Why is not possible to create a constant map](https://groups.google.com/g/golang-nuts/c/xUaDMciyB5Q)

## 工具包

### 引入 com
go modules 中导入 com:

```sh
go get github.com/unknwon/com@latest
```

### 获取页码

创建`pagination.go`并写入：

```go
package utils

import (
	"github.com/gin-gonic/gin"
	"github.com/unknwon/com"
	"go-gin-example/global"
)

// GetPage get page size from request and
// calculate offset for querying data in database
func GetPage(c *gin.Context) int {
	result := 0
	page, _ := com.StrTo(c.Query("page")).Int()
	if page > 0 {
		result = (page - 1) * global.AppConfig.App.PageSize
	}
	return result
}
```

## 数据库

### 引入 gorm

安装 gorm :

```
go get -u gorm.io/gorm
```

安装 mysql 驱动：

```
go get -u gorm.io/driver/mysql
```

### 初始化 gorm

`global.go` 新增：

```go
AppDB *gorm.DB
```

在`core`目录下新增`gorm.go`:

```go
package core

import (
	"fmt"
	"go-gin-example/global"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"
	"log"
	"time"
)

type Model struct {
	ID        uint           `gorm:"primarykey" json:"id"`
	CreatedAt time.Time      `json:"createdAt"`
	UpdatedAt time.Time      `json:"updatedAt"`
	DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
}

// Gorm initialize database connection
func Gorm() {
	// mysql config
	m := global.AppConfig.Database
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		m.User, m.Password, m.Host, m.Port, m.Name)
	db, err := gorm.Open(mysql.New(mysql.Config{
		DSN: dsn,
	}), &gorm.Config{
		NamingStrategy: schema.NamingStrategy{
			TablePrefix:   global.AppConfig.Database.TablePrefix, // set table name prefix
			SingularTable: true,                                  // use singular table name
		},
	})
	if err != nil {
		log.Fatalf("open database failed, %s", err)
	}
	// 获取通用数据库对象 sql.DB ，然后使用其提供的功能
	sqlDB, _ := db.DB()

	// SetMaxIdleConns 用于设置连接池中空闲连接的最大数量。
	sqlDB.SetMaxIdleConns(10)

	// SetMaxOpenConns 设置打开数据库连接的最大数量。
	sqlDB.SetMaxOpenConns(100)

	// SetConnMaxLifetime 设置了连接可复用的最大时间。
	sqlDB.SetConnMaxLifetime(time.Hour)

	global.AppDB = db
}

func CloseDB() {
	sqlDB, _ := global.AppDB.DB()
	defer sqlDB.Close()
}

```

这里的`Model`因为需要配置 struct tag(如 json),没有使用 gorm 提供的`gorm.Model`,但是字段是一样的

在 gorm 配置中， NamingStrategy 指定命名策略：

- TablePrefix : 指定表名前缀为 “blog”
- SingularTable : 采用单数表名

## 应用入口

 创建`main.go`并写入：

```go
package main

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"go-gin-example/core"
	"go-gin-example/global"
	"net/http"
)

func main() {
	// initialize
	core.Viper()
	core.Gorm()
	core.CloseDB()
	// router
	r := gin.Default()
	r.GET("/ping", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"message": "pong",
		})
	})
	// Listen and serve
	s := &http.Server{
		Addr: fmt.Sprintf(":%d",global.AppConfig.Server.HttpPort),
		Handler: r,
		ReadTimeout: global.AppConfig.Server.ReadTimeout,
		WriteTimeout: global.AppConfig.Server.WriteTimeout,
		MaxHeaderBytes: 1<<20,
	}
	s.ListenAndServe()
}
```

启动程序，执行:

```sh
curl 127.0.0.1:9090/ping
{"message":"pong"}
```

### http.Server 和 ListenAndServe

上例使用了`http.Server`,部分结构字段如下：

```go
type Server struct {
    Addr    string
    Handler Handler
    TLSConfig *tls.Config
    ReadTimeout time.Duration
    ReadHeaderTimeout time.Duration
    WriteTimeout time.Duration
    IdleTimeout time.Duration
    MaxHeaderBytes int
    ConnState func(net.Conn, ConnState)
    ErrorLog *log.Logger
    // ...
}
```

- Addr : 监听地址
- Handler : 路由handler
- TLSConfig : 安全传输层协议(TLS)的配置
- ReadTimeout : 最大读取时间
- WriteTimeout : 最大写入时间
- IdleTimeout: 最大等待时间
- MaxHeaderByrtes : 请求头最大字节数
- ConnState : 指定回调函数，客户端连接发生变化时使用
- ErrorLog : 指定一个可选的日志记录器，用于接收程序的意外行为和底层系统错误，默认使用标准日志包

`server.ListenAndServe`:

```go
func (srv *Server) ListenAndServe() error {
	if srv.shuttingDown() {
		return ErrServerClosed
	}
	addr := srv.Addr
	if addr == "" {
		addr = ":http"
	}
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		return err
	}
	return srv.Serve(ln)
}
```

开启TCP监听，并处理请求，`ListenAndServe`的 receiver 为指针类型，故需要用指针类型调用

`http.ListenAndServe`:

```go
func ListenAndServe(addr string, handler Handler) error {
	server := &Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}
```

这里创建了默认配置的`http.Server`,再调用`ListenAndServer` 方法

gin 中的 `Run` :

```go
func (engine *Engine) Run(addr ...string) (err error) {
	defer func() { debugPrintError(err) }()

	trustedCIDRs, err := engine.prepareTrustedCIDRs()
	if err != nil {
		return err
	}
	engine.trustedCIDRs = trustedCIDRs
	address := resolveAddress(addr)
	debugPrint("Listening and serving HTTP on %s\n", address)
	err = http.ListenAndServe(address, engine)
	return
}
```

`Run`方法中调用了`http.ListenAndServe`

相较于直接使用`Run`方法启动 http 服务，使用`http.Server`来调用`ListenAndServe`方法更具灵活性，方便自定义配置

### gin.Default

上例使用了`gin.Default`创建路由，在启动后会打印`WARNING`日志

```
[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.
```

```go
func Default() *Engine {
	debugPrintWARNINGDefault()
	engine := New()
	engine.Use(Logger(), Recovery())
	return engine
}

```

```go
func debugPrintWARNINGDefault() {
	if v, e := getMinVer(runtime.Version()); e == nil && v <= ginSupportMinGoVer {
		debugPrint(`[WARNING] Now Gin requires Go 1.12+.

`)
	}
	debugPrint(`[WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

`)
}
```

可以看到`Default`在最开是就打印了此日志，之后附加了 Logger 和 Recovery 中间件 

## 配置 Router

上例将 router 逻辑直接写在了`main.go`中不方便维护，这里将其提取出来

在`core`目录下创建`router.go`用于初始化路由：

```go
package core

import (
	"github.com/gin-gonic/gin"
	"go-gin-example/routers"
)

func Router() *gin.Engine{
	router := gin.Default()
	group := router.Group("")
	routers.InitTagRouter(group)
	routers.InitArticleRouter(group)
	return router
}
```

这里配置了路由分组，方便后续扩展维护

### 路由分组

在`routers`中创建路由分组：

`article.go`:

```go
package routers

import "github.com/gin-gonic/gin"

func InitArticleRouter(group *gin.RouterGroup) {
   tagGroup := group.Group("article")
   {
      tagGroup.GET("/test", func(c *gin.Context) {
         c.JSON(200,gin.H{
            "message":"test",
         })
      })
   }
}
```

`tag.go`:

```go
package routers

import "github.com/gin-gonic/gin"

func InitTagRouter(group *gin.RouterGroup) {
	tagGroup := group.Group("tag")
	{
		tagGroup.GET("/test", func(c *gin.Context) {
			c.JSON(200,gin.H{
				"message":"test",
			})
		})
	}
}
```

修改`main.go`:

```go
package main

import (
	"fmt"
	"go-gin-example/core"
	"go-gin-example/global"
	"net/http"
)

func main() {
	// initialize
	core.Viper()
	core.Gorm()
	core.CloseDB()
	// router
	router := core.Router()
	// Listen and serve
	s := &http.Server{
		Addr: fmt.Sprintf(":%d",global.AppConfig.Server.HttpPort),
		Handler: router,
		ReadTimeout: global.AppConfig.Server.ReadTimeout,
		WriteTimeout: global.AppConfig.Server.WriteTimeout,
		MaxHeaderBytes: 1<<20,
	}
	s.ListenAndServe()
}
```

启动服务，可以看到路由分组：

```
[GIN-debug] GET    /tag/test                 --> go-gin-example/routers.InitTagRouter.func1 (3 handlers)
[GIN-debug] GET    /article/test             --> go-gin-example/routers.InitArticleRouter.func1 (3 handlers)
```

现在的目录结构：

```
go-gin-example
├── api
├── conf
│   └── config.yml
├── core
│   ├── gorm.go
│   ├── router.go
│   └── viper.go
├── global
│   └── global.go
├── middleware
├── models
│   ├── config
│   │   ├── app.go
│   │   ├── config.go
│   │   ├── database.go
│   │   └── server.go
│   └── response
│       ├── code.go
│       └── msg.go
├── routers
│   ├── article.go
│   └── tag.go
├── runtime
├── utils
│   └── pagination.go
├── blog_init.sql
├── go.mod
├── go.sum
└── main.go
```

## API 接口

### 引入 validation

在 Web 应用中，验证用户的输入是非常重要的，这里引入`github.com/astaxie/beego/validation`来进行参数的验证

```
go get -u github.com/astaxie/beego/validation
```

### 自定义路由

在编写接口之前，先修改路由的初始化，使用自定义配置的路由而不是 gin 的默认路由

修改`core/router.go`:

```go
package core

import (
	"github.com/gin-gonic/gin"
	"go-gin-example/global"
	"go-gin-example/routers"
)

func Router() *gin.Engine{
	router := gin.New()
	router.Use(gin.Logger())
	router.Use(gin.Recovery())
	gin.SetMode(global.AppConfig.RunMode)
	group := router.Group("/v1")
	routers.InitTagRouter(group)
	routers.InitArticleRouter(group)
	return router
}
```

router 使用 gin 提供的 logger 和 recovery 中间件，将 gin 运行模式改为从配置中读取，将分组路径改为`v1`,表示 api 版本为`v1`

### Tag

采用 RESTful 编写 API：

- 获取标签列表 : GET(“/tags”)
- 新建标签 : POST(“/tags”)
- 更新指定标签 : PUT(“/tags/:id”)
- 删除指定标签 : DELETE(“/tags/:id”)

在`api/v1`目录下创建`tag.go`:

```go
package v1

import "github.com/gin-gonic/gin"
// GetTags get tag list exists
func GetTags(c *gin.Context) {

}

// AddTag add a article tag
func AddTag(c *gin.Context) {

}

// EditTagById change tag by id
func EditTagById(c *gin.Context) {

}

// DeleteTagById delete a tag by id
func DeleteTagById(c *gin.Context) {

}
```

这里先创建 api，后续补充逻辑

在`routers/tag.go`中注册路由：

```go
package routers

import (
	"github.com/gin-gonic/gin"
	v1 "go-gin-example/api/v1"
)

func InitArticleRouter(group *gin.RouterGroup) {
	tagGroup := group.Group("article")
	{
		tagGroup.GET("/tags", v1.GetTags)
		tagGroup.POST("/tags", v1.AddTag)
		tagGroup.PUT("/tags", v1.EditTagById)
		tagGroup.DELETE("/tags", v1.DeleteTagById)
	}
}
```

可以启动服务查看路由是否注册成功

#### 配置 model

在`models`目录创建`tag.go`

```go
package models

import "go-gin-example/core"

type Tag struct {
	core.Model
	Name      string `json:"name"`
	State     int    `json:"state"`
	CreatedBy string `json:"createdBy"`
	UpdatedBy string `json:"updatedBy"`
}

```

