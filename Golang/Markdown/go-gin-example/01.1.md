---
title: Gin搭建Blog API (1)
date: '2021-11-08'
categories:
 - 'golang'
tags:
 - 'gin'
publish: true
---

# Gin搭建Blog API

## 初始化

### 项目目录

创建项目目录`go-gin-example`,并添加以下目录：

```
go-gin-example
├── conf
├── global
├── core
├── middleware
├── models
├── routers
├── runtime
└── utils
```

- conf : 用于存储配置文件
- middleware : 应用中间件
- models : 应用数据库模型
- global : 全局变量，viper, gorm 等
- routers : 路由逻辑处理
- runtime : 应用运行时数据
- core : 应用核心组件
- utils : 工具包

这里将原项目中的`pkg`改为`global`，将需要全局调用的变量存放于此，如 viper,gorm 等

### go modules

进入`go-gin-example`,执行：

```sh
go mod init go-gin-example
```

添加依赖：

```
go get github.com/gin-gonic/gin@latest
```

这里没有在`go.mod`中使用`replace`，因为自己实践的这个项目不是独立的 github 仓库，无需使用远程包，使用本地包即可

go modules replace 的使用场景可以参考 [Go Module’s Replace](https://levelup.gitconnected.com/go-modules-replace-3ea6d0139c91)

### 初始化数据库

创建文件`blog_init.sql`并写入：

```sql
-- 若不存在则创建数据库 blog, 字符编码为 utf8, 校验规则为 utf8_general_ci 不区分大小写
CREATE DATABASE IF NOT EXISTS blog CHARSET utf8 COLLATE utf8_general_ci;
-- 进入数据库 blog
USE `blog`;
-- 标签表
CREATE TABLE IF NOT EXISTS `blog_tag` (
	`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `name` varchar(100) DEFAULT '' COMMENT '标签名称',
    `state` tinyint(3) unsigned DEFAULT '1' COMMENT '状态 0 禁用，1 启用',
    `created_by` varchar(100) DEFAULT  '' COMMENT '创建人', 
    `updated_by` varchar(100) DEFAULT '' COMMENT '修改人',
    `created_at` datetime,
    `updated_at` datetime,
    `deleted_at` datetime,
    PRIMARY KEY (id)
)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '文章标签管理';
-- 文章表
CREATE TABLE IF NOT EXISTS `blog_article` (
	`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `tag_id` int(10) unsigned DEFAULT '0' COMMENT 'tag id',
    `title` varchar(100) DEFAULT '' COMMENT '文章标题',
    `description` varchar(255) DEFAULT '' COMMENT '文章描述',
    `content` text COMMENT '文章内容',
    `state` tinyint(3) unsigned DEFAULT '1' COMMENT '状态 0 禁用，1 启用',
    `created_by` varchar(100) DEFAULT '' COMMENT '创建人',
   	`updated_by` varchar(100) DEFAULT '' COMMENT '修改人',
    `created_at` datetime,
    `updated_at` datetime,
    `deleted_at` datetime,
    PRIMARY KEY (id)
)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '文章管理';
-- 认证表
CREATE TABLE IF NOT EXISTS `blog_auth` (
	`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
    `username` varchar(50) DEFAULT '' COMMENT '用户名',
    `password` varchar(50) DEFAULT '' COMMENT '密码',
    `created_by` varchar(100) DEFAULT '' COMMENT '创建人',
    `updated_by` varchar(100) DEFAULT '' COMMENT '修改人',
    `created_at` datetime,
    `updated_at` datetime,
    `deleted_at` datetime,
    PRIMARY KEY (id)
)ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT '认证管理';
-- 插入 admin
INSERT INTO `blog`.`blog_auth` (`username`,`password`,`created_at`) VALUES ('admin','admin',NOW());
```

原项目使用的`gorm`版本为`v0.0.0`,当前`gorm`版本为`v1.2.2`(`gorm`在`v1.2.0`版本进行重构)，由于此原因此处将表结构稍作改变

登入 Mysql ：

```sh
mysql -u root -p
```

执行脚本：

```sh
source $HOME/golang-notes/go-gin-example/blog_init.sql
```

## 项目配置

### 引入 viper

原项目使用的是`go-ini`用于读取`ini`配置，这里我使用`viper`进行配置读取

在项目根目录(go.mod所在目录)执行：

```go
go get 
```



### 配置文件

在`conf`目录下创建配置文件`config.yml`,写入以下内容:

```yaml
# debug or release
run-mode: debug
# application
app:
  page-size: 10
  jwt-secret: 23347$040412
# server
server:
  http-port: 9090
  read-timeout: 60
  write-timeout: 60
# database
database:
  type: mysql
  user: username
  password: password
  host: 127.0.0.1
  port: 3306
  name: blog
  table-prefix: blog_
```

### 配置结构体

在`global`目录下创建`global.go`：

```go
package global

import "go-gin-example/models/config"

var (
	AppConfig config.Config
)

```

在`models`创建`config`文件夹，配置相关的相关的结构体放在这里：

创建`config.go`并写入：

```go
package config

type Config struct {
	RunMode  string   `mapstructure:"run-mode"`
	App      App      `mapstructure:"app"`
	Server   Server   `mapstructure:"server"`
	Database Database `mapstructure:"database"`
}
```

`app.go` :

```go
package config

type App struct {
	PageSize  int    `mapstructure:"page-size"`
	JwtSecret string `mapstructure:"jwt-secret"`
}
```

`server.go` :

```go
package config

type Server struct {
	HttpPort     string `mapstructure:"http-port"`
	ReadTimeout  int    `mpstructure:"read-timeout"`
	WriteTimeout int    `mapstructure:"write-timeout"`
}
```

`database.go` : 

```go
package config

type Database struct {
	Type        string `mapstructure:"type"`
	User        string `mapstructure:"user"`
	Password    string `mapstructure:"password"`
	Host        string `mapstructure:"host"'`
	Port        int    `mapstructure:"port"`
	Name        string `mapstructure:"name"`
	TablePrefix string `mapstructure:"table-prefix"`
}
```

### 初始化 viper

在 `core` 目录下创建`viper.go`并写入：

```go
package core

import (
	"fmt"
	"github.com/fsnotify/fsnotify"
	"github.com/spf13/viper"
	"go-gin-example/global"
	"log"
)

func Viper() {
	viper.SetConfigName("config")
	viper.SetConfigType("yaml")
	viper.AddConfigPath("./conf")
	err := viper.ReadInConfig()
	if err != nil {
		panic(fmt.Errorf("fatal error config file : %w \n", err))
	}
	// watching and re-reading config files
	viper.OnConfigChange(func(e fsnotify.Event) {
		log.Printf("Config file changed, name:%s, op:%s", e.Name, e.Op)
		err = viper.Unmarshal(&global.AppConfig)
		if err != nil {
			log.Printf("Re-reading config failed, %v", err)
		}
	})
	viper.WatchConfig()
	// decode config into struct
	err = viper.Unmarshal(&global.AppConfig)
	if err != nil {
		log.Fatalf("Unable decode config into struct, %v ", err)
	}
}

```

现在的目录结构：

```
go-gin-example
├── conf
│   └── config.yml
├── core
│   └── viper.go
├── global
│   └── global.go
├── middleware
├── models
│   └── config
│       ├── app.go
│       ├── config.go
│       ├── database.go
│       └── server.go
├── routers
├── runtime
├── go.mod
├── go.sum
└── main.go
```

## API错误码

在`models`中新增`response`目录，创建`code.go`并写入：

```go
package response

const (
	Success       = 200
	Error         = 500
	InvalidParams = 400

	ErrorExistTag        = 10001
	ErrorNotExistTag     = 10002
	ErrorNotExistArticle = 10003

	ErrorAuthCheckTokenFail    = 20001
	ErrorAuthCheckTokenTimeout = 20002
	ErrorAuthToken             = 20003
	ErrorAuth                  = 20004
)
```

关于常量的命名，原项目中使用全大写加下划线的形式(ALL_CAPS)，这里采用驼峰命名，和标准库的命名类似（参考：[Go naming conventions for const](https://stackoverflow.com/questions/22688906/go-naming-conventions-for-const)）

配置错误信息，`msg.go`:

```go
package response

var msgFlags = map[int]string{
	Success:                    "ok",
	Error:                      "fail",
	InvalidParams:              "request parameters error",
	ErrorExistTag:              "tag already exists",
	ErrorNotExistTag:           "tag not exists",
	ErrorNotExistArticle:       "article not exists",
	ErrorAuthCheckTokenFail:    "check token failed",
	ErrorAuthCheckTokenTimeout: "token timeout",
	ErrorAuthToken:             "token generate failed",
	ErrorAuth:                  "token error",
}

func GetMsg(code int) string {
	msg, ok := msgFlags[code]
	if ok {
		return msg
	}
	return msgFlags[Error]
}
```

注意这里的map不能是`const`,常量只能是数字，字符，字符串和布尔值

>Constants in Go are just that—constant. They are created at compile time, even when defined as locals in functions, and can only be numbers, characters (runes), strings or booleans. Because of the compile-time restriction, the expressions that define them must be constant expressions, evaluatable by the compiler. For instance, 1<<3 is a constant expression, while math.Sin(math.Pi/4) is not because the function call to math.Sin needs to happen at run time.

可以参考[effective go](http://golang.org/doc/effective_go.html#constants)和[Why is not possible to create a constant map](https://groups.google.com/g/golang-nuts/c/xUaDMciyB5Q)

## 工具包

### 引入 com
go modules 中导入 com:

```sh
go get github.com/unknwon/com@latest
```

### 获取页码

创建`pagination.go`并写入：

```go
package utils

import (
	"github.com/gin-gonic/gin"
	"github.com/unknwon/com"
	"go-gin-example/global"
)

// GetPage get page size from request and
// calculate offset for querying data in database
func GetPage(c *gin.Context) int {
	result := 0
	page, _ := com.StrTo(c.Query("page")).Int()
	if page > 0 {
		result = (page - 1) * global.AppConfig.App.PageSize
	}
	return result
}
```

## 数据库

### 引入 gorm

安装 gorm :

```
go get -u gorm.io/gorm
```

安装 mysql 驱动：

```
go get -u gorm.io/driver/mysql
```

## 初始化 gorm

`global.go` 新增：

```go
AppDB *gorm.DB
```

在`core`目录下新增`gorm.go`:

```go
package core

import (
	"fmt"
	"go-gin-example/global"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"log"
	"time"
)

// Gorm initialize database connetction
func Gorm() {
	// mysql config
	m := global.AppConfig.Database
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		m.User, m.Password, m.Host, m.Port, m.Name)
	db, err := gorm.Open(mysql.New(mysql.Config{
		DSN: dsn,
	}), &gorm.Config{})
	if err != nil {
		log.Fatalf("open database failed, %s", err)
	}
	// 获取通用数据库对象 sql.DB ，然后使用其提供的功能
	sqlDB, _ := db.DB()

	// SetMaxIdleConns 用于设置连接池中空闲连接的最大数量。
	sqlDB.SetMaxIdleConns(10)

	// SetMaxOpenConns 设置打开数据库连接的最大数量。
	sqlDB.SetMaxOpenConns(100)

	// SetConnMaxLifetime 设置了连接可复用的最大时间。
	sqlDB.SetConnMaxLifetime(time.Hour)

	global.AppDB = db
}

func CloseDB() {
	sqlDB, _ := global.AppDB.DB()
	defer sqlDB.Close()
}
```



