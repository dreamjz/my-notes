---
title: "167. Two sum ii input array is sorted"
date: '2022-02-23'
categories:
 - leetcode
tags:
 - array
publish: true
---

## 1. 题目描述

给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。

以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。

你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

```
示例 1：
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。

示例 2：
输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。

示例 3：
输入：numbers = [-1,0], target = -1
输出：[1,2]
解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```

## 2. 分析

此题可以使用「[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)」的解法，暴力枚举或者使用哈希表（但是哈希表不满足常量级的空间复杂度）。但是没有利用上有序数组的特性，若利用好有序的特性，可以得到更优的算法。

## 3. 题解

### 3.1 二分查找

在数组中找到两个数，使得它们的和等于目标值，首先固定第一个数，然后寻找第二个数（等于目标值减去第一个数的差）。

因为数组是有序的，可以通过二分查找寻找第二个数。为避免重复查找，只在第一个数的右侧寻找。

```go
func twoSum(numbers []int, target int) []int {
    n := len(numbers)
    for i := 0; i < n; i++ {
        left, right := i + 1, n - 1
        for left <= right {
            mid := (left + right) / 2
            x := target - numbers[i]
            if x == numbers[mid] {
                return []int{i+1, mid+1}
            } else if x < numbers[mid] {
                right = mid - 1
            } else {
                left = mid + 1
            }
        }
    }
    return []int{-1, -1}
}
```

复杂度分析：

- 时间复杂度：*O(n logn)*，其中 n 为数组长度。遍历获取第一个数，复杂度为 *O(n)*，二分查找第二个数，复杂度为 *O(logn)*，因此总时间复杂度为 *O(n logn)*
- 空间复杂度：*O(1)*。

### 3.2 双指针

初始时两个指针分别指向第一个元素和最后一个元素。每次计算指针指向的两个元素之和，与目标值比较。

- 若和等于目标值，则发现唯一解。
- 若和小于目标值，则将左指针右移一位。
- 若和小于目标值，则将右指针左移一位。

使用双指针的实质是缩小查找范围，会不会把可能的解过滤掉？

不会，假设 *numbers[i] + numbers[j] = target* 是唯一解，其中 *0 <= i < j <= numbers.length - 1*，左指针指向的下标小于等于 *i*，右指针指向的下标大于或等于 *j*。除非初始时左指针和右指针已经位于下标 *i* 和 *j*，否则一定是左指针到达下标 *i* 或 右指到达下标 *j*：

- 若左指针先到达下标 *i* 的位置，此时右指针还在 *j* 的右侧，*sum > target*，因此一定是右指针左移，左指针不可能移动到 *i* 的右侧。
- 若右指针先到达下标 *j* 的位置，此时左指针还在下标 *i* 的左侧，*sum < target*，因此一定是左指针右移，右指针不可能移动到 *j* 的左侧。

由此可见，在移动过程中，左指针不可能到 *i* 的右侧，而右指针不可能移动到 *j* 的左侧，因此不会将可能的解漏掉。

```go
func twoSum(numbers []int, target int) []int {
    left, right := 0, len(numbers) - 1
    for left < right {
        sum := numbers[left] + numbers[right]
        if sum == target {
            return []int{left+1, right+1}
        } else if sum < target {
            left++
        } else {
            right--
        }
    }
    return []int{-1, -1}
}
```

复杂度分析：

- 时间复杂度： *O(n)*，其中 n 为数组的长度。两个指针移动的总次数最多为 n 次。
- 空间复杂度：*O(1)*。

## Reference

1. [167. Two sum ii input array is sorted](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)
2. [官方题解](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-by-leet-2/)
